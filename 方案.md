# Fix Plan: run_sub_agent persistence + multi-session + stop

## Symptoms
- While run_sub_agent is running, switching pages or sessions clears the live steps.
- Clicking Stop does not reliably stop run_sub_agent.
- Multiple sessions running at once should all keep their progress visible.

## Root Causes
- Live steps live only in UI memory (useChatSessions subagentStreams) and are fed by chat:event streams. When ChatView unmounts or state resets, there is no durable storage to rehydrate.
- stopStreaming refuses to call chat:abort when streamState is missing, so after view/session switches the abort signal never reaches the running tool.
- There is no durable mapping from toolCallId to subagent job_id, making explicit cancellation from the UI/backend difficult if abort does not reach the tool call handler.

## Fix Plan
1) Persist subagent steps in the database (not just in-memory cache).
   - Add a new table (e.g., subagentStreams) in the chat DB or reuse admin events with a compact payload.
   - Key by sessionId + toolCallId, store job_id, steps (bounded length), status, updatedAt.
   - On each notifications/progress (subagent_router, kind=subagent_step), upsert steps in DB and also emit chat:event to UI.
   - Add IPC handler chat:subagent:streams to fetch persisted steps for a session (or all sessions).
   - In useChatSessions, rehydrate subagentStreams on mount and when switching sessions using chat:subagent:streams.

2) Make Stop reliably cancel run_sub_agent.
   - Relax stopStreaming guard so it calls chat:abort even if streamState is missing.
   - Ensure run_sub_agent abort propagates to subagent_router (tool handler already cancels job_id on AbortError).
   - Persist job_id from progress notifications for mapping/debug; mark DB streams done on abort/tool_result.

3) Multi-session safety + cleanup.
   - Keep subagentStreams map keyed by sessionId to avoid cross-session mixing.
   - When tool_result arrives or job is done/cancelled, mark the DB record as done and optionally prune steps after TTL.
   - Keep a bounded step count (e.g., last 200) to avoid DB bloat.

4) Observability.
   - Log subagent_async_start/subagent_async_progress/subagent_async_cancel with sessionId/toolCallId/job_id in events.jsonl for diagnosis.

## Validation
- Start run_sub_agent, switch to another page/session, then return: live steps should still be visible and continue updating.
- Run two sessions in parallel: each shows its own subagent progress without cross-contamination.
- Click Stop during run_sub_agent: job should be cancelled, no further progress events, and UI shows aborted state.
